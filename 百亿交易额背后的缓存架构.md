# 百亿交易额背后的缓存架构总结

架构师视角：整体、全局观、不仅仅是java，因而缓存的实现架构也不仅仅是普通BE认为的redis。

__缓存__： 把数据从慢的地方拿到快的地方，主要针对查询场景，本质是高性能的读写操作。传统的架构中，数据存储在关系型数据库中，最终存储在磁盘上，通过机械臂的转动寻址，在计算机上是速度最慢的介质（也有好处，可靠，有事务，ACID），需要增加缓存，把数据拿到读取很快的地方。

## 缓存类型   
- 本地缓存
- 分布式缓存
- 数据库缓存
- 浏览器(http)缓存

<img src="./images/本地缓存+redis" alt="本地缓存">

### 本地缓存
本地缓存就是将数据放在JVM堆中，实现方式可以是任意的集合：List，Map等，该缓存资源属于进程，在分布式环境中，每个线程都使用本地缓存会增加内存消耗，同时进程结束缓存也就消失了。

### 分布式缓存
分布式环境下引入分布式缓存中间件，相当于将缓存和进程进行解耦，不需要在每个进程中都保留缓存资源，同时进程的生命周期与缓存无关，同时速度很快，redis可以保证每秒几十万次的请求


|比较项|单机缓存|分布式缓存中间件|
|--|-----|-----|
|运行方式|嵌入单一进程内部的存储区域|独立启动的进程|
|交互方式|通过内存直接访问|通过网络访问|
|读取速度|纳秒级别|毫秒级别|
|实现|map、guava、ehcache|redis、memcached|
|优缺点|速度快。只能在单进程内部使用，同样的数据存储在不同的进程，导致缓存维护成本高，内存占有率高|速度快，多进程共用，节约内存成本和缓存维护成本|

### 数据库缓存
数据库支持缓存实现，有缓存开关。数据库缓存实现是对sql进行完全比较，select和SELECT是不一样的，即区分大小写。

### 浏览器(http)缓存
在浏览器发起请求后，有时候得到的是200，有时候得到的是304，这是为啥呢？浏览器发送请求如何使用缓存的，流程是怎么样的呢？为什么有的结果会缓存有的结果不缓存呢？ 

#### 缓存流程
浏览器的缓存和服务端缓存一样为key-value形式，key即为uri，浏览器通过uri去缓存中查询缓存和缓存标识。第一次发起请求时，缓存中没有数据，于是浏览器发起请求，服务器返回结果，并在response的header中加入相应的缓存标识，响应码为200，浏览器获取到结果后，将结果和header中的缓存标识存入缓存.第二次请求时，浏览器查询缓存，得到缓存结果和缓存标识，浏览器在header中加入缓存标识的值向浏览器发起请求，浏览器进行请求处理，根据请求header中的标识确定要不要将处理结果返回给浏览器，如果需要返回，则响应码为200，否则304，response为空。

##### Etag缓存标识原理
Etag由服务器端生成，客户端通过If-Match或者If-None-Match这个条件判断请求来验证资源是否修改，常见的是使用If-None-Match,请求一个文件的流程如下：
-- 第一次请求 -- 
1. 客户端发起Http的get请求获取一个文件
2. 服务器处理请求，返回文件内容和一堆header，其中包括Etag(eg: Etag="23dh-jldfs-232",响应内容的md5)，假设服务器支持Etag生成和已开启Etag，状态码为200
-- 第二次请求 --
1. 客户端发起一个Http的get请求，该请求header中会有一个If-None-Match头，值为第一次请求返回的Etag值
2. 服务器判断发送过来的Etag和计算出来的Etag是否匹配，如果匹配，If-None-Match为false，返回304，使用本地缓存
3. 如果还有Cache-Control:Max-age和Expires策略，会一起使用，每个策略都满足才会返回304    
**在springboot中，可以通过ShallowEtagHeaderFilter来实现Etag的缓存策略**

#### 为什么有的会缓存有的不会缓存
是否缓存是由服务器返回的response的header中缓存标识决定的。

#### 为什么得到处理结果后需要判断而不是直接返回 
答案：节约带宽
带宽即为每秒能传输的数据量，运营商提供的带宽值是每秒传输的比特位（bit），我们response大小正常的计算是byte，因此运营商的100M宽带实际能传输的大小并不是没秒100MB，而是100Mb，相当于12MB的样子，如果一个response的大小为12KB，那么运营商提供的100M宽带每秒只能响应1024个response，因此如果使用304状态码，response为空，不会占用带宽。

#### 浏览器缓存标识
##### 强缓存
不会向服务器发送请求，直接使用缓存，在chrome控制台的network可以看到该请求返回200，并在size显示from disk cache或者from memory cache。相关的header包括：**Expire**、**Cache-Control**。   
1. Expires 
缓存过期时间，用来指定资源的到期时间，是服务器端的具体时间点。也就是说，Expires=max-age + 请求时间，需要结合**Last-modified**使用。该header是服务器给客户端的响应头，告诉客户端在过期时间前可以直接使用缓存内容而不用再次请求。
Expires是HTTP/1的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。
2. Cache-Control  
HTTP/1中，cache-control是最重要的规则，主要用于控制网页缓存。当  
```
cache-control：max-age=300
```
代表这个请求正确返回后的5分钟内再次加载资源，会命中强缓存。
cache-control可在请求头和响应头中设置，可以组合多种指令：  
|指令|作用|
|-|-|
|public|表示响应可以被客户端和代理服务器缓存|
|private|用户私有缓存，表示响应只可以被客户端缓存，代理服务器不应该缓存|
|max-age=30|30s内缓存有效|
|s-maxage=30|同上，只在代理服务器生效|
|no-store|不缓存任何响应|
|no-cache|资源被缓存，但立即失效，下次会发起请求验证资源是否过期(使用Etag或者Last-Modified验证)|
|max-stale=30|30s内，即使缓存过期，也使用该缓存(CDN缓存)|
|min-fresh=30|希望在30s内获取最新响应|

s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。比如当s-maxage=60时，在这60秒中，即使更新了CDN的内容，浏览器也不会进行请求。max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age。如果存在s-maxage，则会覆盖掉max-age和Expires header。

3. Cache-Control的优先级高于Expires，强缓存判断是否缓存的依据来自于是否超过某个时间点或者时间段，不关心服务端内容是否更新，可能会导致加载的文件不是最新的内容。可以通过协商缓存来获取最新内容。

##### 协商缓存
强缓存失效后，浏览器携带缓存标识发起请求，服务端根据缓存标识决定是否使用缓存。
协商缓存有效，返回304，协商缓存失效，返回200,实现方式：Last-Modified、Etag
1. Last-Modified和Last-Modified-Since  
浏览器第一次访问，服务端返回资源，同时在response的header中加入Last-Modified，值为资源最后修改时间。浏览器接收后缓存返回结果和缓存标识。
第二次请求时，浏览器查询缓存，得到缓存和Last-Modified的header值，于是在request的header中加入If-Modified-Since，值为服务器返回的Last-Modified的值。服务器接收到请求后，将该值与资源的最后修改时间进行比较，如果没有变化，返回304和空的response，浏览器直接使用缓存的内容，如果该值小于服务器资源的最后修改时间，说明文件有更新，返回新资源和200。
```
Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT
```
弊端：
- 如果本地打开缓存文件，即使没有修改，还是会造成Last-Modified被修改，服务器不能命中缓存导致发送相同的资源   
- Last-Modified以秒为单位，在一秒内如果有改变是无法感知的，如果是负载均衡服务器，每个服务器生成的Last-Modified可能不一致。

2. Etag和If-None-Match
Etag由服务器端生成，客户端通过If-Match或者If-None-Match这个条件判断请求来验证资源是否修改，常见的是使用If-None-Match,请求一个文件的流程如下：
-- 第一次请求 -- 
- 客户端发起Http的get请求获取一个文件
- 服务器处理请求，返回文件内容和一堆header，其中包括Etag(eg: Etag="23dh-jldfs-232",响应内容的md5)，假设服务器支持Etag生成和已开启Etag，状态码为200
-- 第二次请求 --
- 客户端发起一个Http的get请求，该请求header中会有一个If-None-Match头，值为第一次请求返回的Etag值
- 服务器判断发送过来的Etag和计算出来的Etag是否匹配，如果匹配，If-None-Match为false，返回304，使用本地缓存
- 如果还有Cache-Control:Max-age和Expires策略，会一起使用，每个策略都满足才会返回304 

Last-Modified vs ETag  
精度方面： Etag优于Last-Modified
性能上： Etag略逊与Last-Modified，前者需要计算，后者只需要存储一个时间
优先级上：服务端校验优先考虑ETag

##### 使用场景
频繁变动：Cache-Control：no-cache，不会减少请求数量，但会减少响应数据大小。
不常变化的资源：Cache-Control：max-age=31536000
同样的URL会命中强制缓存，为了解决更新问题，需要在文件名或路径中加入版本或者和版本、文件相关的hash，达到更改url的目的。


